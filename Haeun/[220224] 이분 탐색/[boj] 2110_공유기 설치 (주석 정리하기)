#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int binarySearch(vector<int> v, int find_value)
{
	int begin = 0;
	int end = v.size() - 1;
	int mid = 0;

	while (begin <= end && begin >= 0 && end <= v.size() - 1)
	{
		mid = (begin + end) / 2;
		if (v[mid] == find_value)
			return mid;

		else if (v[mid] < find_value)
			begin = mid + 1;
		else //v[mid] > find_value
			end = mid - 1;
	}

	return -1;
}
bool isPossibleInterval(int routerNum, int interval,int* maxInterval, vector<int>& v)
{
	int idx = 0;
	for (int i = 0; i < routerNum; i++)
	{
		int nextIdx = lower_bound(v.begin(), v.end(), v[idx] + interval)-v;
		if (nextIdx < v.size() && nextIdx >= 0)//주어진 간격이 가능함
			idx = nextIdx;
		
		else return false;

	}


	*maxInterval = interval;
	return true;

}
int main(void)
{
	int homeNum = 0, routerNum =0;
	scanf_s("%d %d", &homeNum, &routerNum);

	vector<int> homeList(homeNum);
	//아예 index == 좌표로 한다면? 구현이 더 쉽지 않을까?
	//근데 가능한 집의 좌표가 너무 커서 낭비가 심할듯

	for (int i = 0; i < homeNum; i++)
		scanf_s("%d", &homeList[i]);

	//집 좌표 기준으로 오름차순 정렬
	sort(homeList.begin(), homeList.end());
	int firstLastInterval = homeList.back() - homeList.front();
	int maxInterval = 0;

	if (routerNum == 2)
		printf("%d", firstLastInterval);
	
	else
	{
		for (int i = firstLastInterval; i > 0; i--)
		{
			if (isPossibleInterval(routerNum, i, &maxInterval, homeList))
				break;
			
		}
		printf("%d", maxInterval);
		
	}
	

	
}
